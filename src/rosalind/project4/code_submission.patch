diff --git a/approximate_matcher/__init__.py b/approximate_matcher/__init__.py
index e6dfe04..80e06b4 100644
--- a/approximate_matcher/__init__.py
+++ b/approximate_matcher/__init__.py
@@ -11,7 +11,7 @@ from seed_and_check import SeedChecker
 class ApproximateMatcher:
     def __init__(self, target):
         self._text = target + '$'
-        self._bwt = BWT(self._text)
+        self._bwt = BWT(target=self._text)
 
     # return indices in target that contain
     # matches of string pattern with up to d
@@ -24,6 +24,7 @@ class ApproximateMatcher:
         for seed, seed_index in seed_checker.enumerate():
             # find exact matches of seed using BWT
             indices = self._bwt.get_matches(seed)
+
             # add candidate approximate matches based on
             # seed exact matches
             seed_checker.add_candidates(indices, seed_index)
diff --git a/approximate_matcher/bwt/__init__.py b/approximate_matcher/bwt/__init__.py
index fd95ca7..9cb8fa4 100644
--- a/approximate_matcher/bwt/__init__.py
+++ b/approximate_matcher/bwt/__init__.py
@@ -13,7 +13,23 @@ from preprocess_bwt import _get_first_occurence_fn, _get_count_fn
 #       bwt: string containing the Burrows-Wheeler transform of text
 #       suffix_array: the suffix array of text
 def _construct(text):
-    return text, range(len(text))
+    # rotate text so that last character of rotation is on the appropriate position
+    # i.e. the ith position has the last character of the rotation that
+    # starts at the ith position in text (this is not the same order that
+    # the rotations are listed on pg. 326 of Compeau & Pevzner
+    rotated_text = text[-1] + text[:-1]
+
+    # make tuples of character in bwt and the rotation it corresponds to
+    indexed_chars = zip(list(rotated_text), [i for i in xrange(len(text))])
+
+    # sort tuples by corresponding rotations
+    # the key function return the rotated text starting at appropriate index
+    sorted_chars = sorted(indexed_chars, key=lambda x: text[x[1]:] + text[:x[1]])
+
+    # extract the bwt characters after sorting rotations
+    bwt_chars, indices = zip(*sorted_chars)
+    bwt = ''.join(list(bwt_chars))
+    return bwt, indices
 
 # wrapper for the processing functions used to compute
 # auxiliary data structures for efficient BWT matching
@@ -44,10 +60,16 @@ def _preprocess_bwt(bwt):
 #   `bwt.count(symbol, position)` returns the number of occurrences of symbol
 #       up to given position in BWT of target string
 class BWT:
-    def __init__(self, target):
+    def __init__(self, target=None):
         self._text = target
-        self._bwt, self._suffix_array = _construct(self._text)
-        self.first_occurence, self.count = _preprocess_bwt(self._bwt)
+        self._bwt = None
+        self._suffix_array = None
+        if target is not None:
+            self._bwt, self._suffix_array = _construct(self._text)
+        self.first_occurence = None
+        self.count = None
+        if target is not None:
+            self.first_occurence, self.count = _preprocess_bwt(self._bwt)
 
     # THIS IS A STUB, YOU NEED TO IMPLEMENT THIS
     #
@@ -68,7 +90,12 @@ class BWT:
 
         # return matching indices based on top and bottom pointers
         # YOU NEED TO FILL THIS IN
-        return []
+        return self._suffix_array[top:(bottom+1)]
+
+    # find pointer in first column of last occurence of symbol
+    # before 'index' in last column
+    def _move_pointer(self, symbol, index):
+        return self.first_occurence(symbol) + self.count(symbol, index)
 
     # THIS IS A STUB, YOU NEED TO IMPLEMENT THIS
     #
@@ -83,4 +110,21 @@ class BWT:
     #       sorted rotations table that start with exact matches to query string
     #       returns (-1, -1) if no matches are found
     def _get_matching_rows(self, pattern):
+        # have top and bottom pointers at first and last
+        # row of M matrix
+        top = 0
+        bottom = len(self._bwt) - 1
+
+        # while there are rows to be checked
+        while top <= bottom:
+            # and patterns symbols to be checked
+            if len(pattern) > 0:
+                symbol = pattern[-1] # check the last symbol in pattern
+                pattern = pattern[:-1] # remove last symbol in pattern
+
+                # update top and bottom pointers
+                top = self._move_pointer(symbol, top)
+                bottom = self._move_pointer(symbol, bottom + 1) - 1
+            else:
+                return (top,bottom)
         return (-1, -1)
diff --git a/approximate_matcher/bwt/preprocess_bwt.py b/approximate_matcher/bwt/preprocess_bwt.py
index 8044126..4578c74 100644
--- a/approximate_matcher/bwt/preprocess_bwt.py
+++ b/approximate_matcher/bwt/preprocess_bwt.py
@@ -15,10 +15,14 @@ import numpy as np
 #   location of symbol in first column of rotation matrix for bwt
 def _get_first_occurence_fn(bwt):
     first_occurences = dict()
+
     # find first occurrence of each symbol in the
     # first column of rotation table
-
-    # YOU NEED TO FILL THIS IN
+    bwt = sorted(bwt) # sort bwt
+    for i in xrange(len(bwt)):
+        symbol = bwt[i]
+        if symbol not in first_occurences:
+            first_occurences[symbol] = i
 
     # return function that returns first occurrence
     # for a given symbol
@@ -38,26 +42,32 @@ def _get_first_occurence_fn(bwt):
 #   such that f(symbol, position) gives the number of occurences
 #   of symbol up to given position in bwt
 def _get_count_fn(bwt):
-    # figure out symbols occuring in bwt
+    # figure out symbols occuring in text
     counter = defaultdict(int)
-    for c in bwt:
-        counter[c] += 1
+    for symbol in bwt:
+        counter[symbol] += 1
     symbols = counter.keys()
 
     # allocate count table
     count = np.zeros((len(bwt)+1, len(symbols)), dtype=np.int32)
 
     # fill in count table with running count
-    # of occurence counts, at the end
+    # of occurences, at the end
     # count[position, index] has the number of
     # occurrences in bwt up to `position` of symbol
     # corresponding to column `index`, see below
-
-    # YOU NEED TO FILL THIS IN
+    for i in xrange(len(bwt)):
+        symbol = bwt[i]
+        vec = np.array(count[i,])
+        index = symbols.index(symbol)
+        # increase running count for symbol
+        vec[index] += 1
+        count[i+1,:] = vec
 
     # return function that return precomputed count
     # i.e., number of occurrences of `symbol`
     # up to `position` in bwt
+    # function that return precomputed count
     def fn(symbol, position):
         index = symbols.index(symbol)
         return count[position, index]
diff --git a/approximate_matcher/seed_and_check/__init__.py b/approximate_matcher/seed_and_check/__init__.py
index 62fcdef..f35f8c3 100644
--- a/approximate_matcher/seed_and_check/__init__.py
+++ b/approximate_matcher/seed_and_check/__init__.py
@@ -13,7 +13,26 @@
 #       seeds: array of strings, contains seed non-overlapping k-mers obtained from pattern
 #       k: overlapping k-mer length
 def _make_seeds(pattern, d):
-    return [], 0
+    n = len(pattern)
+    k = n / (d + 1)
+
+    # split pattern into d + 1 seeds each of at least length k
+    seeds = []
+    while len(pattern) >= k:
+        seeds.append(pattern[:k])
+        pattern = pattern[k:]
+
+    # check corner case where we made one too many seeds
+    if len(seeds) > d+1:
+        last = seeds[-1]
+        seeds = seeds[:-1]
+        seeds[-1] += last
+
+    # add any remaining characters to last seed
+    if len(pattern) > 0:
+        seeds[-1] += pattern
+    return seeds, k
+
 
 # THIS IS A STUB, YOU NEED TO IMPLEMENT THIS
 #
@@ -24,7 +43,14 @@ def _make_seeds(pattern, d):
 #   target: string, target string
 #   d: minimum number of mismatches
 def _within_edit_distance(pattern, target, d):
-    return False
+    n = len(pattern)
+    num_mismatches = 0
+    i = 0
+
+    while i < len(target) and i < n and num_mismatches <= d:
+        num_mismatches += 1 if pattern[i] != target[i] else 0
+        i += 1
+    return num_mismatches <= d and i == n
 
 # class encapsulating the seed-and-check strategy
 # for approximate matching
