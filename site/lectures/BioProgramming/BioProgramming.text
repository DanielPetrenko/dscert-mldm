% CMSC423: Programming for Bioinformatics
% Hector Corrada Bravo
% Fall 2013

<!--In this lecture we discuss programming  in Bioinformatics and Computational Biology.-->

<!--We saw in the previous lecture the types of entities, processes and artifacts we study in Bioinformatics and Computational Biology:
genome sequences, gene expression measurements, networks of protein relationships/interactions. And others that we didn't
discuss directly but implied: sequence alignments (pairwise and multiple), assemblies, phylogenetic trees, variants in populations, etc.-->

# Entities, processes and artifacts

There are libraries available for almost all commonly-used programming languages to manage these types of data:

bioconductor: R
biopython: python
seqan: C++
bioperl: perl
bioruby: ruby
biojava: java

The purpose of these libraries are pretty much identical for all of them:

1)	Connect to databases  
2)	Data structures for fundamental objects  
3)	Basic operations/algorithms on these structures  
4)	Tools for communication  

There is a large quantity and variety of public databases of biomedical data. 
For example, Genbank, Refseq, unigene, short read archive, ensembl, gene expression omnibus, KEGG, Gene ontology
We will discuss many of these in the next lecture

Data stored here are usually in a standardized format: 
FASTA sequence  
FASTQ sequence and quality  
GTF/GFF genomic features  
MIAME for expression data  

Programming libraries make connections to these databases and parsing of these standard formats easy.
You went through an example in the BioPython tutorial

xxxx

Libraries also encapsulate many of these standards into data structures for the given language. For example,
BioPython provides the sequence classes you saw in the tutorial.

Another example is the `GenomicRanges` classes in R/Bioconductor that encapsulate intervals in the genome to represent genomic features (e.g., genes, exons, introns)

Another great example is the `ExpressionSet` class in R/Biocondcutor that encapsulate gene expression experiments.

These libraries provide basic operations on these data structures, both standard in computing languages, like aggregation. But also operations that
are specific to the bio data they encapsulate, for example, sequence classes can calculate the complement and reverse complements of DNA sequences, or translate from DNA sequence to amino acid sequence.

As a bioinformatician and computational biologist, a lot of our job is to *communicate* the result of computations: for example, if we design
a new sequence mapping or alignment algorithm, we need to demonstrate its performance characteristis. If we use these algorithms to perform a specific task, say compare the sequences of different strains of the influenza virus, we need to present the result of our comparison.

These libraries also provide tools for this type of communication with data: tools to visualize data, provide documentation of algorithms and tools, etc.

One very important aspect that has been given a lot of attention lately is the issue of *reproducibility*. Many of these programming languages
provide tools for reproducible computation and communication of results. You should even think of these standard bioinformatics libraries themselves as tools for reproducible work since by avoiding the need to reimplement many basic operations, programmer error is reduced, and since these tools have fairly large userbases, there is a 'community watchdog' effect that strives for quality. Also, standard practices in software engineering can help attain this goal, e.g., version control, unit testing

Some tips:

In many projects you can divide tasks into modular sections. Frequently these are:
1.	Data acquisition: get data, put it in usable format (many join operations sometimes), clean it up  
2.	Algorithm development: if new analysis tools are required for an experiment  
3.	Computational analysis: Use tools to analyze data  
4.	Communication of results: Prepare summaries of experimental results, plots, publish, upload processed data to repositories  

Not all languages are equally suited for each section. Choose the best tool for the job: frequently I find that python or shell scripting is good for #1, C/C++/python/R are good for #2 depending on the type of algorithm. Many times #3 is best managed as shell scripts. I almost always use R for #4.
Usually all of this is managed by a *pipeline* of python/shell/R scripts. 

This type of modularity requires good organization and careful thought. In bioinformatics we wear two hats: algorithm developer and experimentalist.
It helps to separate those two jobs (especially for reproducibility).

Remember: think as an experimentalist. Plan your experiment, gather your raw data and tools (this may include developing new algorithms), execute, analyze.

You should organize your tools accordingly. For instance, I find the following organization useful for projects:

More thinking like an experimentalist: keep a lab notebook! Be clear when specifying your plan, keep careful notes.

New tools are making this very easy for programming workflows, based on Don Knuth's *literate programming* idea. Ipython notebook, Rmarkdown.

More thinking like an experimentalist: separate your experiment from your communication. Store the results of computations, write separate scripts to analyze the results.

I can't stress this enough: there are serious consequences to not being careful. Let's take a look at one example.


